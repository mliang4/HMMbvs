# name the transition
tempName = "ID"
for (i in 2:(ncol(tempTrans)-6)){
tempName = c(tempName, paste0("tVar",i))
}
tempName = c(tempName, "curr", "prev", "delta", "time", "firstobs", "length")
names(tempTrans) = tempName
# build the transition
while(tempTrans$time[nrow(tempTrans)] < window){
lastRow = nrow(tempTrans) # how many rows does tempTrans currently have?
if(tempTrans$curr[lastRow] == 0){
tempTrans$prev[lastRow] = 1 # Make previous transition state 1
# Set rate for transition to 1
tranIndex = c(2:(ncol(tempTrans)-6))  # 1 is id, last 6 are cur, pre, del, tim, fir, len
rate = lambda_0 * exp( as.matrix(tempTrans[lastRow, tranIndex]) %*% beta_lambda )
}else if(tempTrans$curr[lastRow] == 1){
tempTrans$prev[lastRow] = 0 # Make previous transition state 0
# Set rate for transition to 0
tranIndex = c(2:(ncol(tempTrans)-6))  # 1 is id, last 6 are cur, pre, del, tim, fir, len
rate = mu_0 * exp( as.matrix(tempTrans[lastRow, tranIndex]) %*% beta_mu )
}
tempTrans$length[lastRow] = rexp(1, rate = rate) # log time of transition
if(lastRow == 10){ var2 = rbinom(1,1,.5) }
# Binary covariate (var2) changes value if obs transitions more than 10 times,
# it can randomly switch for the remainder
conRW = as.numeric(tempTrans[lastRow,4] + rmnorm(n = 1, rep(0,1), .001*diag(1)))
# Continous covariates that follow random walk (var4)
# Update states and time
curr = tempTrans$prev[lastRow]
prev = NA  # fill this in retrospectively
t = sum(tempTrans$length)
delta = 1 # always the case because of when the measurememt times are set (every unit)
# Append the new transition to the temp data frame
newTrans = c(id, var2, var3, conRW, conVar[2:length(conVar)],
curr, prev, delta, t, 0, NA) # vector of new transition for subject i
tempTrans = rbind(tempTrans, newTrans) # append new transition
}
# Parse through temp files to collect OBSERVED states with covariates
# Use the random list of observation times
obs = data.frame()
random_obs = sort(runif(window,0,window))
tmp = cbind(tempTrans[1,],0)
colnames(tmp)[ncol(tmp)]="i"
obs = rbind(obs, tmp)
for(i in random_obs){ # obs time
for(j in 1:nrow(tempTrans)){ # real transition time
if( (tempTrans$time[j] <= i) & (i <= tempTrans$time[j+1]) ){
obs <- rbind(obs, cbind(tempTrans[j,],i))
}
}
}
names(obs)[ncol(obs)] = "obs_time"
# Adjust next state given observations (not transitions) and adjust delta
for(i in 2:nrow(obs)){
obs$prev[i] <- obs$curr[(i-1)]
obs$delta[i] <- obs$obs_time[i] - obs$obs_time[i-1]
}
obs$prev[1] = NA
# add true state to list
trueState = c(trueState,obs$curr)
# build emission covariate matrix
nEmis = length(beta_0)-2
cont2 = rmnorm(n=1, rep(0,nEmis), correl + (1-correl)*diag(nEmis))
# borrowed 2 covariates from transition
emisX = NULL
for(i in 1:nrow(obs)){
emisX = rbind(emisX,c(cont2[1],cont2[2]+rnorm(1,0,0.1),cont2[3:length(cont2)]))
}
emisX = cbind(obs$tVar2, obs$tVar4, emisX) # first two covariates for emission is from transition
tempName = c("tVar2","tVar4")
for (i in 3:length(beta_0)){
tempName = c(tempName, paste0("eVar",i))
}
colnames(emisX) = tempName
rownames(emisX) = c(1:nrow(obs))
# build emission
ytmp = NULL # initialize observation
for (i in 1:nrow(obs)){
if (obs$curr[i] == 0){
p = intercept_0*exp( as.numeric(emisX[i,]) %*% beta_0 ) / (  1 + intercept_0*exp( as.numeric(emisX[i,]) %*% beta_0 ) )
p = 1-p
ytmp = c(ytmp,rbinom(1,1,p)) # 1-p chance observe 1 <==> probability of telling truth is p
}else if(obs$curr[i] == 1){
p = intercept_1*exp( as.numeric(emisX[i,]) %*% beta_1 )/  (  1 + intercept_1*exp( as.numeric(emisX[i,]) %*% beta_1 ) )
ytmp = c(ytmp,rbinom(1,1,p)) # again telling truth probability is p
}
}
# attach emission covariates and observation to obs data frame
obs = cbind(obs, emisX, ytmp)
allSubjTab = rbind(allSubjTab,obs)
}
# clean up the data frame
# adjust delta accordingly
for (i in 1:nrow(allSubjTab)){
if (is.na(allSubjTab$prev[i])){
allSubjTab$delta[i] = NA
}
}
cav = allSubjTab
# cav$ytmp = cav$ytmp-1
twoway4.q <- rbind(c(0, 0.15), c(0.3, 0)) # qmatrix
rownames(twoway4.q) <- colnames(twoway4.q) <- c("Non-smoke", "Smoke")
statetable.msm(ytmp, subject=ID, data=cav)
covaf = as.formula("~tVar2+tVar3+tVar4+tVar5+tVar6")
misc.msm <- msm(ytmp ~ obs_time, subject = ID, data = cav,
qmatrix = twoway4.q,
# ematrix = ematrix,
covariates = covaf,
# misccovariates = miscf,
hcovariates = list(~tVar2+tVar4+eVar3+eVar4+eVar5,~tVar2+tVar4+eVar3+eVar4+eVar5),
hmodel = list(hmmBinom(size=1, prob=0.5),hmmBinom(size=1, prob=0.5)), control = list(maxit = 20000) )
betatrue
betatrue[13:24]
misc.msm$estimates
rm(list = ls())
library(reshape)
library(mnormt)
library(abind)
library(msm)
ind = 150
window = 30
prob = 0.8
emisP = prob
print(emisP)
set.seed(10234)
correl = 0
# set fixed parameters
lambda_0 = 0.5
mu_0 = 0.5
# beta_lambda = c(1, -1, 0, 0, 0)
# beta_mu = c(1, 0, 0, -1, 0)
# intercept_0 = 1/(1/emisP-1)
# intercept_1 = 1/(1/emisP-1)
# beta_0 = c(-1, 1, 0, 1, 0)
# beta_1 = c(0, -1, 0, 1, 1)
beta_lambda = c(1, -1, 0, 0, 0, rep(0,25))
beta_mu = c(1, 0, 0, -1, 0, rep(0,25))
intercept_0 = 1/(1/emisP-1)
intercept_1 = 1/(1/emisP-1)
beta_0 = c(1, 0, -1, 0, 0, rep(0,15))
beta_1 = c(0, -1, 0, 1, 0, rep(0,15))
betatrue = c(log(lambda_0),beta_lambda,log(mu_0),beta_mu,log(intercept_0),beta_0,log(intercept_1),beta_1)
# initialize for later use
allSubjTab = data.frame()
trueState = NULL
for(id in 1:ind){
# initialize temporary table to store transition information
tempTrans = data.frame()
# variables to put in transition data frame
var2 = rbinom(1,1,.5) # (let's call intercept var1)
var3 = rbinom(1,1,.5)
conNum = length(beta_lambda) - 2
conVar = rmnorm(n = 1, rep(0,conNum), correl + (1-correl)*diag(conNum)) # continuous variable
# curr = rbinom(1, 1, .5)
curr = 1
prev = NA  # fill this in retrospectively
t = 0
delta = 1 # always the case because of when the measurememt times are set (every unit)
# initialize the transition
newTrans = c(id, var2, var3, conVar, curr, prev, delta, t, 1, NA) # vector of new transition for subject i
tempTrans <- rbind(tempTrans, newTrans) # append new transition
# name the transition
tempName = "ID"
for (i in 2:(ncol(tempTrans)-6)){
tempName = c(tempName, paste0("tVar",i))
}
tempName = c(tempName, "curr", "prev", "delta", "time", "firstobs", "length")
names(tempTrans) = tempName
# build the transition
while(tempTrans$time[nrow(tempTrans)] < window){
lastRow = nrow(tempTrans) # how many rows does tempTrans currently have?
if(tempTrans$curr[lastRow] == 0){
tempTrans$prev[lastRow] = 1 # Make previous transition state 1
# Set rate for transition to 1
tranIndex = c(2:(ncol(tempTrans)-6))  # 1 is id, last 6 are cur, pre, del, tim, fir, len
rate = lambda_0 * exp( as.matrix(tempTrans[lastRow, tranIndex]) %*% beta_lambda )
}else if(tempTrans$curr[lastRow] == 1){
tempTrans$prev[lastRow] = 0 # Make previous transition state 0
# Set rate for transition to 0
tranIndex = c(2:(ncol(tempTrans)-6))  # 1 is id, last 6 are cur, pre, del, tim, fir, len
rate = mu_0 * exp( as.matrix(tempTrans[lastRow, tranIndex]) %*% beta_mu )
}
tempTrans$length[lastRow] = rexp(1, rate = rate) # log time of transition
if(lastRow == 10){ var2 = rbinom(1,1,.5) }
# Binary covariate (var2) changes value if obs transitions more than 10 times,
# it can randomly switch for the remainder
conRW = as.numeric(tempTrans[lastRow,4] + rmnorm(n = 1, rep(0,1), .001*diag(1)))
# Continous covariates that follow random walk (var4)
# Update states and time
curr = tempTrans$prev[lastRow]
prev = NA  # fill this in retrospectively
t = sum(tempTrans$length)
delta = 1 # always the case because of when the measurememt times are set (every unit)
# Append the new transition to the temp data frame
newTrans = c(id, var2, var3, conRW, conVar[2:length(conVar)],
curr, prev, delta, t, 0, NA) # vector of new transition for subject i
tempTrans = rbind(tempTrans, newTrans) # append new transition
}
# Parse through temp files to collect OBSERVED states with covariates
# Use the random list of observation times
obs = data.frame()
random_obs = sort(runif(window,0,window))
tmp = cbind(tempTrans[1,],0)
colnames(tmp)[ncol(tmp)]="i"
obs = rbind(obs, tmp)
for(i in random_obs){ # obs time
for(j in 1:nrow(tempTrans)){ # real transition time
if( (tempTrans$time[j] <= i) & (i <= tempTrans$time[j+1]) ){
obs <- rbind(obs, cbind(tempTrans[j,],i))
}
}
}
names(obs)[ncol(obs)] = "obs_time"
# Adjust next state given observations (not transitions) and adjust delta
for(i in 2:nrow(obs)){
obs$prev[i] <- obs$curr[(i-1)]
obs$delta[i] <- obs$obs_time[i] - obs$obs_time[i-1]
}
obs$prev[1] = NA
# add true state to list
trueState = c(trueState,obs$curr)
# build emission covariate matrix
nEmis = length(beta_0)-2
cont2 = rmnorm(n=1, rep(0,nEmis), correl + (1-correl)*diag(nEmis))
# borrowed 2 covariates from transition
emisX = NULL
for(i in 1:nrow(obs)){
emisX = rbind(emisX,c(cont2[1],cont2[2]+rnorm(1,0,0.1),cont2[3:length(cont2)]))
}
emisX = cbind(obs$tVar2, obs$tVar4, emisX) # first two covariates for emission is from transition
tempName = c("tVar2","tVar4")
for (i in 3:length(beta_0)){
tempName = c(tempName, paste0("eVar",i))
}
colnames(emisX) = tempName
rownames(emisX) = c(1:nrow(obs))
# build emission
ytmp = NULL # initialize observation
for (i in 1:nrow(obs)){
if (obs$curr[i] == 0){
p = intercept_0*exp( as.numeric(emisX[i,]) %*% beta_0 ) / (  1 + intercept_0*exp( as.numeric(emisX[i,]) %*% beta_0 ) )
p = 1-p
ytmp = c(ytmp,rbinom(1,1,p)) # 1-p chance observe 1 <==> probability of telling truth is p
}else if(obs$curr[i] == 1){
p = intercept_1*exp( as.numeric(emisX[i,]) %*% beta_1 )/  (  1 + intercept_1*exp( as.numeric(emisX[i,]) %*% beta_1 ) )
ytmp = c(ytmp,rbinom(1,1,p)) # again telling truth probability is p
}
}
# attach emission covariates and observation to obs data frame
obs = cbind(obs, emisX, ytmp)
allSubjTab = rbind(allSubjTab,obs)
}
# clean up the data frame
# adjust delta accordingly
for (i in 1:nrow(allSubjTab)){
if (is.na(allSubjTab$prev[i])){
allSubjTab$delta[i] = NA
}
}
# allSubjTab[,c(4:6,15:18)] = scale(allSubjTab[,c(4:6,15:18)])
#################################################################
# msm PACKAGE in R
#################################################################
cav = allSubjTab
# cav$ytmp = cav$ytmp-1
twoway4.q <- rbind(c(0, 0.15), c(0.3, 0)) # qmatrix
rownames(twoway4.q) <- colnames(twoway4.q) <- c("Non-smoke", "Smoke")
# ematrix = rbind(c(0, 0.2), c(0.2, 0)) # ematrix
# rownames(ematrix) <- colnames(ematrix) <- c("Non-smoke", "Smoke")
# cav$curr = cav$curr+1
statetable.msm(ytmp, subject=ID, data=cav)
# covaf = as.formula("~tVar2+tVar3+tVar4+tVar5+tVar6")
covaf = as.formula("~tVar2+tVar3+tVar4+tVar5+tVar6+tVar7+tVar8+tVar9+tVar10+tVar11+tVar12+tVar13+tVar14+tVar15+tVar16+tVar17+tVar18+tVar19+tVar20+tVar21+tVar22+tVar23+tVar24+tVar25+tVar26+tVar27+tVar28+tVar29+tVar30+tVar31")
miscf = as.formula("~tVar2+tVar4+eVar3+eVar4+eVar5+eVar6+eVar7+eVar8+eVar9+eVar10+eVar11+eVar12+eVar13+eVar14+eVar15+eVar16+eVar17+eVar18+eVar19+eVar20")
misc.msm <- msm(ytmp ~ obs_time, subject = ID, data = cav,
qmatrix = twoway4.q,
# ematrix = ematrix,
covariates = covaf,
# misccovariates = miscf,
hcovariates = list(miscf,miscf),
hmodel = list(hmmBinom(size=1, prob=0.5),hmmBinom(size=1, prob=0.5)), control = list(maxit = 20000) )
betatrue
misc.msm$estimates
library(hmmPack)
library(msm)
rm(list = ls())
source('C:/Users/Scott/Desktop/Dropbox/Rice/Research/HMM/HMMcode/MarkovModelPackage/simdat_msmpack.r')
seed = 119
pt=31
pe=21
set.seed(seed)
print("simulating data...")
sim_tmp = sim_dat.msm()
hmmDatmat = sim_tmp[[1]] # dataset with biased observation
msmDatmat = hmmDatmat
trueBeta = sim_tmp[[2]]
trueGamma = as.numeric(trueBeta!=0)
trueGamma[c(1,pt+1,2*pt+1,2*pt+pe+1)]=1
trueState = sim_tmp[[3]]
msmDatmat[,54] = trueState # change the observation to unbiased for MSM
obsState = hmmDatmat[,54]
misc = sim_tmp[[4]]
cav = cbind(hmmDatmat,misc)
twoway4.q <- rbind(c(0, 0.3), c(0.4, 0)) # qmatrix
rownames(twoway4.q) <- colnames(twoway4.q) <- c("Non-smoke", "Smoke")
# ematrix = rbind(c(0, 0.2), c(0.5, 0)) # ematrix
# rownames(ematrix) <- colnames(ematrix) <- c("Non-smoke", "Smoke")
cav$ytmp = cav$`x$ytmp`
cav$ID = cav$`x$ID`
statetable.msm(ytmp, subject=ID, data=cav)
covaf = as.formula("~tVar2+tVar3+tVar4+tVar5+tVar6+tVar7+tVar8+tVar9+tVar10+tVar11+tVar12+tVar13+tVar14+tVar15+tVar16+tVar17+tVar18+tVar19+tVar20+tVar21+tVar22+tVar23+tVar24+tVar25+tVar26+tVar27+tVar28+tVar29+tVar30+tVar31")
miscf = as.formula("~tVar2+tVar4+eVar3+eVar4+eVar5+eVar6+eVar7+eVar8+eVar9+eVar10+eVar11+eVar12+eVar13+eVar14+eVar15+eVar16+eVar17+eVar18+eVar19+eVar20")
misc.msm <- msm(ytmp ~ obs_time, subject = ID, data = cav, qmatrix = twoway4.q, ematrix = ematrix,
covariates = covaf,
hcovariates = list(miscf,miscf),
hmodel = list(hmmBinom(size=1, prob=0.8),hmmBinom(size=1, prob=0.5)),control = list(maxit = 20000))
misc.msm <- msm(ytmp ~ obs_time, subject = ID, data = cav, qmatrix = twoway4.q,
covariates = covaf,
hcovariates = list(miscf,miscf),
hmodel = list(hmmBinom(size=1, prob=0.8),hmmBinom(size=1, prob=0.5)),control = list(maxit = 20000))
# printnew.msm(misc.msm)
nest = length(misc.msm$estimates)
index1 = (nest-(2*pe-2-1)):(nest-(2*pe-2-1)+pe-2)
index2 = (nest-(pe-2)):(nest)
nest-(2*pe-2-1)-1
nest-(2*pe-2-1)-3
int2 = (misc.msm$estimates[nest-(2*pe-2-1)-1])
int1 = (misc.msm$estimates[nest-(2*pe-2-1)-3])
state1 = c(int1,misc.msm$estimates[index1])
state2 = c(int2,-misc.msm$estimates[index2])
beta1 = trueBeta[84:104]
beta0 = trueBeta[63:83]
output = data.frame(state1,beta1,state2,beta0)
View(output)
View(output)
state1 = c(int1,misc.msm$estimates[index1])
state2 = c(-int2,-misc.msm$estimates[index2])
output = data.frame(state1,beta1,state2,beta0)
View(output)
library(hmmPack)
library(msm)
rm(list = ls())
source('C:/Users/Scott/Desktop/Dropbox/Rice/Research/HMM/HMMcode/MarkovModelPackage/simdat_msmpack.r')
seed = 121
pt=31
pe=21
set.seed(seed)
print("simulating data...")
sim_tmp = sim_dat.msm()
hmmDatmat = sim_tmp[[1]] # dataset with biased observation
msmDatmat = hmmDatmat
trueBeta = sim_tmp[[2]]
trueGamma = as.numeric(trueBeta!=0)
trueGamma[c(1,pt+1,2*pt+1,2*pt+pe+1)]=1
trueState = sim_tmp[[3]]
msmDatmat[,54] = trueState # change the observation to unbiased for MSM
obsState = hmmDatmat[,54]
misc = sim_tmp[[4]]
cav = cbind(hmmDatmat,misc)
twoway4.q <- rbind(c(0, 0.3), c(0.4, 0)) # qmatrix
rownames(twoway4.q) <- colnames(twoway4.q) <- c("Non-smoke", "Smoke")
# ematrix = rbind(c(0, 0.2), c(0.5, 0)) # ematrix
# rownames(ematrix) <- colnames(ematrix) <- c("Non-smoke", "Smoke")
cav$ytmp = cav$`x$ytmp`
cav$ID = cav$`x$ID`
# cav$ytmp = cav$ytmp+1
statetable.msm(ytmp, subject=ID, data=cav)
covaf = as.formula("~tVar2+tVar3+tVar4+tVar5+tVar6+tVar7+tVar8+tVar9+tVar10+tVar11+tVar12+tVar13+tVar14+tVar15+tVar16+tVar17+tVar18+tVar19+tVar20+tVar21+tVar22+tVar23+tVar24+tVar25+tVar26+tVar27+tVar28+tVar29+tVar30+tVar31")
miscf = as.formula("~tVar2+tVar4+eVar3+eVar4+eVar5+eVar6+eVar7+eVar8+eVar9+eVar10+eVar11+eVar12+eVar13+eVar14+eVar15+eVar16+eVar17+eVar18+eVar19+eVar20")
misc.msm <- msm(ytmp ~ obs_time, subject = ID, data = cav, qmatrix = twoway4.q,
covariates = covaf,
hcovariates = list(miscf,miscf),
hmodel = list(hmmBinom(size=1, prob=0.8),hmmBinom(size=1, prob=0.5)),control = list(maxit = 20000))
# misccovariates = ~tVar2+tVar4+eVar3+eVar4+eVar5+eVar6+eVar7+eVar8+eVar9+eVar10+eVar11+eVar12+eVar13+eVar14+eVar15+eVar16+eVar17+eVar18+eVar19+eVar20,
# printnew.msm(misc.msm)
nest = length(misc.msm$estimates)
index1 = (nest-(2*pe-2-1)):(nest-(2*pe-2-1)+pe-2)
index2 = (nest-(pe-2)):(nest)
int2 = (misc.msm$estimates[nest-(2*pe-2-1)-1])
int1 = (misc.msm$estimates[nest-(2*pe-2-1)-3])
state1 = c(int1,misc.msm$estimates[index1])
state2 = c(-int2,-misc.msm$estimates[index2])
beta1 = trueBeta[84:104]
beta0 = trueBeta[63:83]
output = data.frame(state1,beta1,state2,beta0)
View(output)
statetable.msm(ytmp, subject=ID, data=cav)
tmp = statetable.msm(ytmp, subject=ID, data=cav)
tmp[1]
tmp[2]
tmp[3]
tmp[4]
tmp[2]/tmp[4]
tmp[2]/(tmp[2]+tmp[4])
tmp[1]/(tmp[1]+tmp[3])
tmp[3]/(tmp[1]+tmp[3])
View(cav)
library(HMMbvs)
?hmmbvs
?HMMbvs
readhoffdata = function(name, header = F){
y = read.table(url(paste0('http://www2.stat.duke.edu/~pdh10/FCBS/Exercises/', name, '.dat')), header = header)
return(y)
}
data92 = readhoffdata("azdiabetes", header = T)
az0 = data92[,-8]
View(az0)
View(data92)
post = function(theta){
a = theta[1]
b = theta[2]
out = 0
N = length(y)
for (i in 1:N){
out = out + ( y[i] * ( a + b*x[i] ) - log ( 1 + exp( a + b*x[i] ) ) )
}
exp(out)
}
########
# 10.2 #
########
library(MASS)
library(coda)
readhoffdata = function(name, header = F){
y = read.table(url(paste0('http://www2.stat.duke.edu/~pdh10/FCBS/Exercises/', name, '.dat')), header = header)
return(y)
}
msparrownest = readhoffdata("msparrownest",header = F)
mean(msparrownest[,1])
# (c)
y = msparrownest[,1]
x = msparrownest[,2]
log_post = function(theta){
a = theta[1]
b = theta[2]
out = 0
N = length(y)
for (i in 1:N){
out = out + ( y[i] * ( a + b*x[i] ) - log ( 1 + exp( a + b*x[i] ) ) )
}
out
}
post = function(theta){
a = theta[1]
b = theta[2]
out = 0
N = length(y)
for (i in 1:N){
out = out + ( y[i] * ( a + b*x[i] ) - log ( 1 + exp( a + b*x[i] ) ) )
}
exp(out)
}
theta=c(1,1)
post(theta)
p=exp(x%*%theta)/(1+exp(x%*%theta))
x=cbind(1,x)
p=exp(x%*%theta)/(1+exp(x%*%theta))
p
sum(dbern(y,p))
library(Rlab)
install.packages("Rlab")
library(Rlab)
?dbern
sum(dbern(y,p))
# (c)
y = msparrownest[,1]
x = msparrownest[,2]
log_post = function(theta){
a = theta[1]
b = theta[2]
out = 0
N = length(y)
for (i in 1:N){
out = out + ( y[i] * ( a + b*x[i] ) - log ( 1 + exp( a + b*x[i] ) ) )
}
out
}
post = function(theta){
a = theta[1]
b = theta[2]
out = 0
N = length(y)
for (i in 1:N){
out = out + ( y[i] * ( a + b*x[i] ) - log ( 1 + exp( a + b*x[i] ) ) )
}
exp(out)
}
opt = optim(par = rep(0,2),  # Initial value(s)
fn = log_post,  # Function to maximize
control = list(fnscale = -1), # max instead of min
hessian = TRUE,  # Compute the Hessian
method = "L-BFGS-B", lower = rep(-1,2), upper = rep(1,2))
log_post(theta)
x2=cbind(1,x)
p=exp(x2%*%theta)/(1+exp(x2%*%theta))
sum(dbern(y,p,log=T))
dnorm(theta)
theta
library(hmmPack)
library(HMMbvs)
remove.packages("HMMbvs", lib="~/R/win-library/3.6")
remove.packages("hmmPack", lib="~/R/win-library/3.6")
getwd()
setwd("C:/Users/Scott/Desktop/testhmm/HMMbvs/")
library(devtools)
setwd()
getwd()
install.packages("devtools")
library(devtools)
devtools::build(vignettes = F)
devtools::install()
library(HMMbvs)
